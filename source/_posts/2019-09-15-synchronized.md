---
layout: post
title: ' synchronized '
comments: true
date: 2019-09-15 18:32:13
updated: 2019-09-15 18:32:13
urlname: synchronized
categories: J2SE
tags:
- synchronized
- 偏向锁
- 可重入锁
- 轻量级锁
- 重量级锁
- 自旋锁
---
**偏向锁      01**

**轻量级锁  00**

**重量级锁  10**

对象在内存中的布局分为三块区域：**对象头，实例数据，填充数据**

·实例对象·

—————

|对象头    |

|实例变量|

|填充数据|

—————

**对象头主要结构是由Mark Word 和 Class Metadata Address 组成**

- **Mark Word**	**存储对象的hashCode、锁信息或分代年龄或GC标志等信息**

- Class Metadata Address	类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。

**Mark Word**存储结构：

| 锁状态   | 25bit        | 4bit         | 1bit是否是偏向锁 | 2bit 锁标志位 |
| -------- | ------------ | ------------ | ---------------- | ------------- |
| 无锁状态 | 对象HashCode | 对象分代年龄 | 0                | 01            |

- 对象头中包含了锁状态，重量级锁标识为10，其中指针指向的是monitor对象（也称为管程或监视器锁）。

- 每个对象都存在着一个monitor与之关联

- 当一个monitor被某个线程持有后，便处于锁定状态

- 在JAVA虚拟机（**HotSpot**）中，monitor是由**ObjectMonitor**实现的。
- 每个**等待锁的线程**都会被封装成**ObjectWaiter**对象
- ObjectMonitor中有两个队列，**_WaitSet** 和 **_EntryList**，用来保存**ObjectWaiter**对象列表

```c++
ObjectMonitor() {
    _header       = NULL;
    _count        = 0; //记录个数
    _waiters      = 0,
    _recursions   = 0;
    _object       = NULL;
    _owner        = NULL; //指向持有ObjectMonitor对象的线程
    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
}
```

- 当**多个线程同时访问一段同步代码**时，首先会**进入 _EntryList 集合**

- 当**线程获取到对象的monitor** 后进入 **_Owner** 区域并把monitor中的owner变量**设置为当前线程**

- 同时monitor中的计数器**count**加1

- 若线程调用 **wait()** 方法，将**释放当前持有的monitor**，**owner变量恢复为null**，**count自减1**，同时**该线程进入 WaitSet集合中**等待被唤醒。

{% asset_img a.png synchronized %}

锁的状态总共有四种，**无锁状态**、**偏向锁**、**轻量级锁**和**重量级锁**。

1. 偏向锁

   Java 6 之后加入的。

   在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此**为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁**。

   核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，**此时Mark Word 的结构也变为偏向锁结构**，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。

   偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。

2. 轻量级锁

   倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，**此时Mark Word 的结构也变为轻量级锁的结构**。轻量级锁能够提升程序性能的依据是**“对绝大部分的锁，在整个同步周期内都不存在竞争”**，注意这是经验数据。需要了解的是，**轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁**。

3. 自旋锁

   轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时**需要从用户态转换到核心态**，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此**自旋锁会假设在不久将来，当前的线程可以获得锁**，因此虚拟机会**让当前想要获取锁的线程做几个空循环**(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。

4. 锁清除

   Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，**通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁**，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间

**偏向锁，轻量级锁都是乐观锁，重量级锁是悲观锁。**

- 一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。
- 一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了。检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程。如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（**偏向锁就是这个时候升级为轻量级锁的**），此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁；如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。
- 轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，**轻量级锁膨胀为重量级锁**，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。



> https://blog.csdn.net/javazejian/article/details/72828483
>
> https://zhuanlan.zhihu.com/p/29866981
